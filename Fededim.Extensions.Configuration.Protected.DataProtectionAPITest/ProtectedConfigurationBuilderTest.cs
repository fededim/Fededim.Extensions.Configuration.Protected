using Microsoft.Extensions.Configuration;
using Xunit;
using System.Globalization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization.Metadata;
using System;
using System.Linq;
using System.IO;
using System.Collections.Generic;
using System.Buffers;
using Xunit.Abstractions;
using System.Xml;
using System.Xml.Linq;

namespace Fededim.Extensions.Configuration.Protected.DataProtectionAPITest
{
    /// <summary>
    /// Possibile movement inside a hierarchical structure: stays at the same level (Current), Go down another level (Down), go up the previous level (Up)
    /// </summary>
    public enum LevelMove { Current, Down, Up };

    /// <summary>
    /// All possible datatypes generated by this test class
    /// </summary>
    public enum DataTypes { Null, WhitespaceString, String, Integer, Double, Boolean, DateTimeOffset, StringArray, IntegerArray, DoubleArray, BooleanArray, DateTimeOffsetArray }


    /// <summary>
    /// Provides general context to all tests, it is executed once before all tests
    /// </summary>
    public class ProtectedConfigurationBuilderTestFixture : IDisposable
    {
        public ProtectedConfigurationBuilderTestFixture()
        {
            // cleans existing XML, JSON and BAK files
            Directory.EnumerateFiles(".", "random_*.json").ToList().ForEach(f => File.Delete(f));
            Directory.EnumerateFiles(".", "random_*.xml").ToList().ForEach(f => File.Delete(f));
            Directory.EnumerateFiles(".", "random_*.bak").ToList().ForEach(f => File.Delete(f));
        }

        public void Dispose()
        {
        }
    }


    public abstract class ProtectedConfigurationBuilderTest
    {
        const int NUMENTRIES = 100000;
        const int STRINGMAXLENGTH = 20;
        const int ARRAYMAXLENGTH = 10;
        const int SUBPURPOSEMAXLENGTH = 8;


        protected String RANDOMJSONFILENAME => $"random_{Random.Next()}.json";
        protected String RANDOMXMLFILENAME => $"random_{Random.Next()}.xml";

        Random Random { get; } = new Random();

        protected DataTypes[] DataTypesValues = (DataTypes[])Enum.GetValues(typeof(DataTypes));
        protected LevelMove[] LevelMoveValues = (LevelMove[])Enum.GetValues(typeof(LevelMove));
        protected TimeZoneInfo[] TimeZoneInfoValues = TimeZoneInfo.GetSystemTimeZones().ToArray();

        protected IProtectProviderConfigurationData ProtectProviderConfigurationData { get; set; }
        protected JsonSerializerOptions JsonSerializerOptions { get; set; }
        protected ITestOutputHelper TestOutputHelper { get; set; }
        protected ProtectedConfigurationBuilderTestFixture Context { get; set; }


        public ProtectedConfigurationBuilderTest(ProtectedConfigurationBuilderTestFixture context, ITestOutputHelper testOutputHelper, IProtectProviderConfigurationData protectProviderConfigurationData)
        {
            Context = context;
            ProtectProviderConfigurationData = protectProviderConfigurationData;
            TestOutputHelper = testOutputHelper;

            JsonSerializerOptions = new JsonSerializerOptions { WriteIndented = true, TypeInfoResolver = new DefaultJsonTypeInfoResolver() };
        }

        protected ProtectedConfigurationBuilderTest()
        {
        }


        /// <summary>
        /// Generates a random ascii string (valid characters from 32 to 126)
        /// </summary>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        protected String GenerateRandomString(int maxLength)
        {
            var stringBuilder = new StringBuilder();

            for (int i = 0; i < Random.Next(1, maxLength); i++)
                stringBuilder.Append(Convert.ToChar(Random.Next(32, 126)));

            return stringBuilder.ToString();

        }



        /// <summary>
        /// custom NextInt64 implementation (missing in net462)
        /// </summary>
        /// <param name="minValue">minimum value for the integer</param>
        /// <param name="maxValue">maximum value for the integer</param>
        /// <returns></returns>
        protected Int64 NextInt64(Int64 minValue, Int64 maxValue)
        {
            return minValue + (Int64)((UInt64)(Random.NextDouble() * ((UInt64)(maxValue - minValue))));
        }



        /// <summary>
        /// helper method to create random values both in datatype and value
        /// </summary>
        /// <returns>tuple with a random datatype <see cref="DataTypes"/> and a random value</returns>
        protected (DataTypes DataType, object Value) GenerateRandomValue()
        {
            var dataType = (DataTypes)DataTypesValues.GetValue(Random.Next(DataTypesValues.Length));

            switch (dataType)
            {
                case DataTypes.Null:
                    return (dataType, null);

                case DataTypes.WhitespaceString:
                    return (dataType, TrimRegexCharsFromProtectData(new String(' ', Random.Next(STRINGMAXLENGTH))));

                case DataTypes.String:
                    return (dataType, TrimRegexCharsFromProtectData(GenerateRandomString(STRINGMAXLENGTH)));

                case DataTypes.Integer:
                    return (dataType, NextInt64(Int64.MinValue, Int64.MaxValue));

                case DataTypes.DateTimeOffset:
                    return (dataType, new DateTimeOffset(NextInt64(DateTimeOffset.MinValue.Ticks + 2 * TimeSpan.TicksPerDay, DateTimeOffset.MaxValue.Ticks - 2 * TimeSpan.TicksPerDay)+TimeZoneInfoValues[Random.Next(TimeZoneInfoValues.Length)].BaseUtcOffset.Ticks,TimeSpan.Zero));

                case DataTypes.Double:
                    return (dataType, NextInt64(Int64.MinValue, Int64.MaxValue) * Random.NextDouble());

                case DataTypes.Boolean:
                    return (dataType, (Random.Next() % 2 == 0) ? true : false);

                case DataTypes.StringArray:
                    var stringArray = new String[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < stringArray.Length; i++)
                    {
                        stringArray[i] = TrimRegexCharsFromProtectData(GenerateRandomString(STRINGMAXLENGTH));
                    }
                    return (dataType, stringArray);

                case DataTypes.BooleanArray:
                    var booleanArray = new Boolean[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < booleanArray.Length; i++)
                        booleanArray[i] = (Random.Next() % 2 == 0) ? true : false;
                    return (dataType, booleanArray);

                case DataTypes.IntegerArray:
                    var integerArray = new Int64[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < integerArray.Length; i++)
                        integerArray[i] = NextInt64(Int64.MinValue, Int64.MaxValue);
                    return (dataType, integerArray);

                case DataTypes.DateTimeOffsetArray:
                    var dateTimeArray = new DateTimeOffset[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < dateTimeArray.Length; i++)
                        dateTimeArray[i] = new DateTimeOffset(NextInt64(DateTimeOffset.MinValue.Ticks + 2 * TimeSpan.TicksPerDay, DateTimeOffset.MaxValue.Ticks - 2 * TimeSpan.TicksPerDay) + TimeZoneInfoValues[Random.Next(TimeZoneInfoValues.Length)].BaseUtcOffset.Ticks, TimeSpan.Zero);
                    return (dataType, dateTimeArray);

                case DataTypes.DoubleArray:
                    var doubleArray = new Double[Random.Next(0, ARRAYMAXLENGTH)];
                    for (int i = 0; i < doubleArray.Length; i++)
                        doubleArray[i] = NextInt64(Int64.MinValue, Int64.MaxValue) * Random.NextDouble();
                    return (dataType, doubleArray);

                default:
                    throw new NotSupportedException($"Datatype not supported {dataType}!");
            }
        }



        protected int CheckConfigurationEntriesAreEqual(IConfigurationRoot configurationRoot, bool skipMissingNullKeys=false)
        {
            int numEntries = 0;

            foreach (var provider in configurationRoot.Providers)
            {
                // this is a hacky yet safe way to speed up test
                if (provider is ProtectedConfigurationProvider && ((ProtectedConfigurationProvider)provider).ProviderDataReadOnly != null)
                {
                    var dataProperty = ((ProtectedConfigurationProvider)provider).ProviderDataReadOnly;

                    foreach (var key in dataProperty)
                    {
                        if (key.Key.Contains("_Plaintext"))
                        {
                            numEntries++;
                            var encryptedKey = key.Key.Replace("_Plaintext", "_Encrypted");
                            if (!dataProperty.TryGetValue(encryptedKey, out var encryptedValue) && skipMissingNullKeys && encryptedKey.Contains("_Null_"))
                                continue;

                            if (key.Value != encryptedValue)
                                throw new InvalidDataException($"Value mismatch: Plaintext Key {key.Key} Value {key.Value} Encrypted Key {encryptedKey} Value {encryptedValue}");

                            // for debugging
                            //TestOutputHelper.WriteLine($"{DateTime.Now}: Checked Key {key.Key} Value {key.Value} Encrypted Key {encryptedKey} Value {dataProperty[encryptedKey]}");
                        }

                    }
                }
                else
                {
                    var queue = new Queue<String>();

                    queue.Enqueue(null);

                    do
                    {
                        var parentPath = queue.Dequeue();
                        foreach (var key in provider.GetChildKeys(new List<String>(), parentPath).Distinct())
                        {
                            var fullKey = parentPath != null ? $"{parentPath}:{key}" : key;

                            if (provider.TryGet(fullKey, out var value))
                            {
                                if (fullKey.Contains("_Plaintext"))
                                {
                                    numEntries++;
                                    var encryptedKey = fullKey.Replace("_Plaintext", "_Encrypted");
                                    if (!provider.TryGet(encryptedKey, out var valueDecrypted) && skipMissingNullKeys && encryptedKey.Contains("_Null_"))
                                        continue;

                                    if (value != valueDecrypted)
                                        throw new InvalidDataException($"Value mismatch: Plaintext Key {fullKey} Value {value} Encrypted Key {encryptedKey} Value {valueDecrypted}");

                                    // for debugging
                                    //TestOutputHelper.WriteLine($"{DateTime.Now}: Checked Key {fullKey} Value {value} Encrypted Key {encryptedKey} Value {valueDecrypted}");
                                }
                            }
                            else
                                queue.Enqueue(fullKey);

                        }
                    } while (queue.Count > 0);
                }
            }

            return numEntries;
        }



        #region "Json Tests and helper methods"

        /// <summary>
        /// Helper method used by <see cref="CreateJsonProtectValue"/> used to convert object values to string.
        /// </summary>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String EntryToJsonValue(DataTypes dataType, object value)
        {
            switch (dataType)
            {
                // with strings we do not need to perform another JSON encoding, it will be done at the end of the generation process when saving the JSON file
                case DataTypes.WhitespaceString:
                case DataTypes.String:
                case DataTypes.StringArray:
                    return value.ToString();

                // for some unknown reason the standard extension method AddJsonFile of ConfigurationBuilder converts boolean lowercase values (true,false) inside a JSON file into upper case boolean strings (True,False)
                // so in order to test everything is fine we need to "serialize" them also in upper case inside Protect:{} tokens
                // when deserializing into a class there in no problem, both false and False will be converted to boolean false and both true and True will be converted to boolean true
                case DataTypes.Boolean:
                case DataTypes.BooleanArray:
                    return String.Format(CultureInfo.InvariantCulture, "{0}", value);

                default:
                    // we remove the " characters,they are already added by CreateJsonProtectValue method
                    return JsonSerializer.Serialize(value, JsonSerializerOptions).Replace("\"", "");
            }
        }


        /// <summary>
        /// Creates a Protect:{<dataToEncrypt>} string for <see cref="GenerateRandomJsonFile"/>
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns>the generated Protect:{<dataToEncrypt>} string</returns>
        protected String CreateJsonProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (value == null)
                return null;

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{EntryToJsonValue(dataType, value)}}}" : $"Protect:{{{EntryToJsonValue(dataType, value)}}}";
        }


        /// <summary>
        /// generates a random hierarchical JSON file with random NUMENTRIES in both datatype and value
        /// </summary>
        /// <returns>the generated filename and the number of the entries (variable due to the generation of the random number of element in arrays)</returns>
        protected (String FileName, int NumEntries) GenerateRandomJsonFile()
        {
            String subPurpose;
            var fileName = RANDOMJSONFILENAME;

            TestOutputHelper.WriteLine($"{DateTime.Now}: Generating a random JSON file with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}...");

            var JSONObject = new JsonObject();

            var currentNode = JSONObject;

            int level = 1;
            int numEntries = 0;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var levelMove = (LevelMove)LevelMoveValues.GetValue(Random.Next(LevelMoveValues.Length));

                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.WhitespaceString:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                        currentNode[entryKey + "Plaintext"] = JsonValue.Create(entryValue.Value);
                        currentNode[entryKey + "Encrypted"] = JsonValue.Create(CreateJsonProtectValue(subPurpose, entryValue.DataType, entryValue.Value));
                        numEntries += 1;
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        currentNode[entryKey + "Plaintext"] = new JsonArray(((Array)entryValue.Value).Cast<object>().Select(obj => JsonValue.Create(obj)).ToArray());
                        currentNode[entryKey + "Encrypted"] = new JsonArray(((Array)entryValue.Value).Cast<object>().Select(obj =>
                        {
                            subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                            return JsonValue.Create(CreateJsonProtectValue(subPurpose, entryValue.DataType, obj));
                        }).ToArray());
                        numEntries += Math.Max(((Array)entryValue.Value).Length,1);
                        break;
                }

                if (levelMove == LevelMove.Down && level < 62)
                {
                    var nextSubLevelKey = $"Sublevel_{++level}";

                    if (!currentNode.ContainsKey(nextSubLevelKey))
                        currentNode[nextSubLevelKey] = new JsonObject();

                    currentNode = currentNode[nextSubLevelKey].AsObject();
                }
                else if (levelMove == LevelMove.Up && level > 1)
                {
                    level--;
                    currentNode = currentNode.Parent.AsObject();
                }
            }


            File.WriteAllText(fileName, JSONObject.ToJsonString(JsonSerializerOptions));

            var fileInfo = new FileInfo(fileName);
            TestOutputHelper.WriteLine($"{DateTime.Now}: File location file://{Path.GetFullPath(fileName).Replace("\\", "/")}");

            return (fileName, numEntries);
        }


        /// <summary>
        /// Generates random json file with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Theory]
        [InlineData(false)]
        [InlineData(true)]
        public void RandomJsonFileTest(bool useJsonWithCommentFileProcessor)
        {
            var stopwatch = new ExtendedStopwatch(start: true, testOutputHelper: TestOutputHelper);

            if (useJsonWithCommentFileProcessor)
                ConfigurationBuilderExtensions.UseJsonWithCommentsProtectFileOption();

            // genererates a JSON file
            var result = GenerateRandomJsonFile();

            stopwatch.Step($"Generated random JSON file ({result.NumEntries} entries size {new FileInfo(result.FileName).Length / 1024} KB)");

            // Encrypts the JSON file
            Assert.True(ProtectProviderConfigurationData.ProtectFiles(".")?.Any());

            stopwatch.Step($"Encrypted random JSON file ({result.NumEntries} entries size {new FileInfo(result.FileName).Length / 1024} KB)");

            // Reads the encrypted JSON file and checks that all encrypted entries do not match DefaultProtectRegexString
            var encryptedJsonDocument = JsonSerializer.Deserialize<Dictionary<string, object>>(File.ReadAllText(result.FileName), JsonSerializerOptions);
            foreach (var node in encryptedJsonDocument)
            {
                if (node.Key.Contains("_Encrypted") && node.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(node.Value.ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted node Key {node.Key} Value {node.Value}!");
            }

            stopwatch.Step("Checked that all random JSON file is encrypted");

            // Loads the JSON with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddJsonFile(result.FileName).Build();

            stopwatch.Step("Loaded and decrypted random JSON file with ProtectedConfigurationBuilder");

            // Foreach xxx_Plaintext key check that its value is equal to xxx_Encrypted
            var checkedEntries = CheckConfigurationEntriesAreEqual(configuration);

            stopwatch.Step($"Checked that {checkedEntries} entries are equal");
        }


        #endregion





        #region "XML Tests and helper methods"

        /// <summary>
        /// Helper method used by <see cref="CreateXmlProtectValue"/> used to convert object values to string.
        /// </summary>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String EntryToXmlValue(DataTypes dataType, object value)
        {
            // performs value serialization
            switch (dataType)
            {
                // with strings we do not need to perform another XML encoding, it will be done at the end of the generation process when saving the XML file
                case DataTypes.WhitespaceString:
                case DataTypes.String:
                case DataTypes.StringArray:
                    return value.ToString();

                //// for some unknown reason the standard extension method AddJsonFile of ConfigurationBuilder converts boolean lowercase values (true,false) inside a JSON file into upper case boolean strings (True,False)
                //// so in order to test everything is fine we need to "serialize" them also in upper case inside Protect:{} tokens
                //// when deserializing into a class there in no problem, both false and False will be converted to boolean false and both true and True will be converted to boolean true
                //case DataTypes.Boolean:
                //case DataTypes.BooleanArray:
                //    return String.Format(CultureInfo.InvariantCulture, "{0}", value);

                default:
                    return ToXmlString(value);
            }

        }



        /// <summary>
        /// Helper method used to encode XML fragments (e.g. raw values)
        /// </summary>
        /// <param name="value">an input value</param>
        /// <returns>the encode XML string representing the input value</returns>
        protected String ToXmlString(object value)
        {
            using (var stringWriter = new StringWriter())
            {
                using (var xmlWriter = new XmlTextWriter(stringWriter))
                {
                    xmlWriter.WriteValue(value);
                    return stringWriter.ToString();
                }
            }
        }



        /// <summary>
        /// Creates a Protect:{<dataToEncrypt>} string for <see cref="GenerateRandomXmlFile"/>
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns>the generated Protect:{<dataToEncrypt>} string</returns>
        protected String CreateXmlProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (String.IsNullOrEmpty(value?.ToString()))
                return value?.ToString();

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{EntryToXmlValue(dataType, value)}}}" : $"Protect:{{{EntryToXmlValue(dataType, value)}}}";
        }




        /// <summary>
        /// Adds a random node to the current XmlDocument either an as attribute or as an element
        /// </summary>
        /// <param name="currentNode">the node on which the new node will be added</param>
        /// <param name="name">the new node name</param>
        /// <param name="value">the new node value</param>
        /// <param name="forceElement">if true, forces the new node to be an element</param>
        /// <returns>always true</returns>
        public bool AddXmlNode(XElement currentNode, string name, DataTypes dataType, object value)
        {
            // with array we must use elememts, with WhitespaceString we must use attributes (whitespace is only preserved there)
            bool forceElement = new List<DataTypes> { DataTypes.StringArray, DataTypes.IntegerArray, DataTypes.DoubleArray, DataTypes.BooleanArray, DataTypes.DateTimeOffsetArray }.Contains(dataType);
            bool forceAttribute = new List<DataTypes> { DataTypes.WhitespaceString }.Contains(dataType);

            String valueString = null;

            var attributeNode = forceAttribute || (!forceElement && Random.Next() % 4 == 0) ? true : false;

            if (value != null)
                valueString = ToXmlString(value);

            if (attributeNode)
            {
                var attribute = new XAttribute(name, valueString ?? String.Empty);
                currentNode.Add(attribute);
            }
            else
            {
                var element = new XElement(name, valueString);
                currentNode.Add(element);
            }

            return true;
        }



        /// <summary>
        /// Generates hierarchical XML file with random NUMENTRIES in both datatype and value
        /// </summary>
        /// <remarks>XML preserves whitespaces only inside attributes and not elements. You can override this by passing some options but unluckily the standard MS XmlConfigurationProvider is configured to ignore them <see href="https://github.com/dotnet/runtime/blob/a5cc707d976a14495462c9c492a921ff0927b8f5/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlStreamConfigurationProvider.cs#L41-L47"/>. Hence we must 2 things: <br/>
        /// - Add Whitespace strings only to attribute <br/>
        /// - Trim whitespace from any string which goes into an element
        /// </remarks>
        /// <returns>the generated filename and the number of the entries (variable due to the generation of the random number of element in arrays)</returns>
        protected (String FileName, int NumEntries) GenerateRandomXmlFile()
        {
            String subPurpose;
            var fileName = RANDOMXMLFILENAME;

            TestOutputHelper.WriteLine($"{DateTime.Now}: Generating a random XML file with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}...");

            var xDocument = new XDocument();
            xDocument.Add(new XElement("root"));

            var currentNode = xDocument.Root;

            int level = 1;
            int numEntries = 0;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var levelMove = (LevelMove)LevelMoveValues.GetValue(Random.Next(LevelMoveValues.Length));

                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.WhitespaceString:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        if (entryValue.DataType == DataTypes.String)
                            entryValue.Value = entryValue.Value.ToString().Trim();

                        AddXmlNode(currentNode, entryKey + "Plaintext", entryValue.DataType, entryValue.Value);
                        AddXmlNode(currentNode, entryKey + "Encrypted", entryValue.DataType, CreateXmlProtectValue(subPurpose, entryValue.DataType, entryValue.Value));

                        numEntries += 1;
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        var arrayElement = new XElement(entryKey + "Plaintext");
                        ((Array)entryValue.Value).Cast<object>().Select((obj, index) => AddXmlNode(arrayElement, $"A_{index}", entryValue.DataType, entryValue.DataType == DataTypes.StringArray ? obj.ToString().Trim() : obj)).ToArray();
                        currentNode.Add(arrayElement);

                        arrayElement = new XElement(entryKey + "Encrypted");
                        ((Array)entryValue.Value).Cast<object>().Select((obj, index) =>
                        {
                            subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;
                            return AddXmlNode(arrayElement, $"A_{index}", entryValue.DataType, CreateXmlProtectValue(subPurpose, entryValue.DataType, entryValue.DataType == DataTypes.StringArray ? obj.ToString().Trim() : obj));
                        }).ToArray();
                        currentNode.Add(arrayElement);

                        numEntries += ((Array)entryValue.Value).Length;   // note IConfigurationBuilder.AddXmlFile does not load empty XML elements like <empty />, see <see href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlStreamConfigurationProvider.cs#L170-L176" />
                        break;
                }

                if (levelMove == LevelMove.Down && level < 62)
                {
                    var nextSubLevelKey = $"Sublevel_{++level}";

                    if (!currentNode.Elements(nextSubLevelKey).Any())
                        currentNode.Add(new XElement(nextSubLevelKey));

                    currentNode = (XElement)currentNode.Elements(nextSubLevelKey).First();
                }
                else if (levelMove == LevelMove.Up && level > 1)
                {
                    level--;
                    currentNode = (XElement)currentNode.Parent;
                }
            }

            xDocument.Save(fileName);

            var fileInfo = new FileInfo(fileName);
            TestOutputHelper.WriteLine($"{DateTime.Now}: File location file://{Path.GetFullPath(fileName).Replace("\\", "/")}");

            return (fileName, numEntries);
        }



        /// <summary>
        /// Generates random xml file with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomXmlFileTest()
        {
            var stopwatch = new ExtendedStopwatch(start: true, testOutputHelper: TestOutputHelper);

            // genererates a XML file
            var result = GenerateRandomXmlFile();

            stopwatch.Step($"Generated random XML file ({result.NumEntries} entries size {new FileInfo(result.FileName).Length / 1024} KB)");

            // Encrypts the XML file
            Assert.True(ProtectProviderConfigurationData.ProtectFiles(".", searchPattern: "*.xml")?.Any());
            
            stopwatch.Step($"Encrypted random XML file ({result.NumEntries} entries size {new FileInfo(result.FileName).Length / 1024} KB)");

            // Reads the encrypted XML file and checks that all encrypted entries do not match DefaultProtectRegexString
            var encryptedXmlDocument = XDocument.Load(result.FileName);
            foreach (var node in encryptedXmlDocument.Descendants())
            {
                // check element is encrypted
                if (node.Name.LocalName.Contains("_Encrypted") && node.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(node.Value.ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted element Key {node.Name.LocalName} Value {node.Value}!");

                // check all its attributes are encrypted
                foreach (var attribute in node.Attributes())
                    if (attribute.Name.LocalName.Contains("_Encrypted") && attribute.Value != null)
                        if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(attribute.Value.ToString()))
                            throw new InvalidDataException($"Found an invalid un-encrypted attribute Key {attribute.Name.LocalName} Value {attribute.Value}!");
            }

            stopwatch.Step("Checked that all random XML file is encrypted");

            // Loads the XML with ProtectedConfigurationBuilder, note that IConfigurationBuilder.AddXmlFile does not load empty XML elements like <empty /> see <see href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlStreamConfigurationProvider.cs#L170-L176" />
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddXmlFile(result.FileName).Build();

            stopwatch.Step("Loaded and decrypted random XML file with ProtectedConfigurationBuilder");

            // Foreach xxx_Plaintext key check that its value is equal to xxx_Encrypted, here we pass true to skipMissingNullKeys because of the previous comment about empty XML elements
            var checkedEntries = CheckConfigurationEntriesAreEqual(configuration,true);

            stopwatch.Step($"Checked that {checkedEntries} entries are equal");
        }

        #endregion






        #region "Environment variables Tests and helper methods"

        /// <summary>
        /// Helper method used to convert object values to protect pure string (no encoding).
        /// </summary>
        /// <param name="subPurpose">per configuration value encryption subkey (e.g. "subpurposes")</param>
        /// <param name="dataType">the autogenerated value datatype</param>
        /// <param name="value">the autogenerated value</param>
        /// <returns></returns>
        protected String CreateStringProtectValue(string subPurpose, DataTypes dataType, object value)
        {
            if (value == null)
                return null;

            return (subPurpose != null) ? $"Protect:{{{subPurpose}}}:{{{value}}}" : $"Protect:{{{value}}}";
        }


        /// <summary>
        /// Generates random environment variables with (2*NUMENTRIES) in both datatype and value. Environment variables can only contain string and they aren't hierarchical.
        /// </summary>
        protected void GenerateRandomEnvironmentVariables()
        {
            String subPurpose;
            var fileName = RANDOMXMLFILENAME;

            TestOutputHelper.WriteLine($"{DateTime.Now}: Generating a random environment variables {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}...");

            // Generate random environments variables
            // 
            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.WhitespaceString:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        Environment.SetEnvironmentVariable(entryKey + "Plaintext", entryValue.Value?.ToString(), EnvironmentVariableTarget.Process);
                        Environment.SetEnvironmentVariable(entryKey + "Encrypted", CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value), EnvironmentVariableTarget.Process);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // environment variables do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        Environment.SetEnvironmentVariable(entryKey + "Plaintext", firstValue, EnvironmentVariableTarget.Process);
                        Environment.SetEnvironmentVariable(entryKey + "Encrypted", CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue), EnvironmentVariableTarget.Process);
                        break;

                    default:
                        throw new NotSupportedException($"{entryValue.DataType}");
                }
            }

            TestOutputHelper.WriteLine($"{DateTime.Now}: Starting test...");
        }


        /// <summary>
        /// Generates random process environment variables with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomEnvironmentVariablesTest()
        {
            var stopwatch = new ExtendedStopwatch(start: true, testOutputHelper: TestOutputHelper);

            // genererates random environment variables
            GenerateRandomEnvironmentVariables();

            stopwatch.Step($"Generated random environment variables (note that Windows has a maximum size of 32KB for all environment variables, so not all {NUMENTRIES} keys could be created)");

            // Encrypts the environment variables
            ProtectProviderConfigurationData.ProtectEnvironmentVariables(EnvironmentVariableTarget.Process);

            stopwatch.Step("Encrypted random environment variables");

            // Checks that all environment variables are encrypted, e.g. do not match DefaultProtectRegexString
            var environmentVariables = Environment.GetEnvironmentVariables(EnvironmentVariableTarget.Process);
            foreach (String key in environmentVariables.Keys)
            {
                if (key.Contains("_Encrypted") && environmentVariables[key] != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(environmentVariables[key].ToString()))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {key} Value {environmentVariables[key]}!");
            }

            stopwatch.Step("Checked that all random environment variables are encrypted");

            // Loads the XML with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddEnvironmentVariables().Build();

            stopwatch.Step("Loaded and decrypted random environment variables with ProtectedConfigurationBuilder");

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            var checkedEntries = CheckConfigurationEntriesAreEqual(configuration);

            stopwatch.Step($"Checked that {checkedEntries} entries are equal");
        }
        #endregion





        #region "In-Memory dictionary Tests and helper methods"

        /// <summary>
        /// Generates a random in-memory dictionary with random 2*NUMENTRIES in both datatype and value. In-memory dictionary can only contain string and it isn't hierarchical.
        /// </summary>
        /// <returns>the generated in-memory dictionary</returns>
        protected Dictionary<String, String> GenerateRandomInMemoryDictionary()
        {
            String subPurpose;

            TestOutputHelper.WriteLine($"{DateTime.Now}: Generating a random in-memory dictionary with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}...");

            var dictionary = new Dictionary<String, String>();

            var currentNode = dictionary;

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.WhitespaceString:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        currentNode[entryKey + "Plaintext"] = entryValue.Value?.ToString();
                        currentNode[entryKey + "Encrypted"] = CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // in-memory dictionaries do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        currentNode[entryKey + "Plaintext"] = firstValue;
                        currentNode[entryKey + "Encrypted"] = CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue);
                        break;
                }
            }


            TestOutputHelper.WriteLine($"{DateTime.Now}: Starting test...");

            return dictionary;
        }


        /// <summary>
        /// Generates random in-memory dictionary with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomInMemoryDictionaryTest()
        {
            var stopwatch = new ExtendedStopwatch(start: true, testOutputHelper: TestOutputHelper);

            // genererates random in-memory dictionary
            var dictionary = GenerateRandomInMemoryDictionary();

            stopwatch.Step("Generated random in-memory dictionary");


            // Encrypts the in-memory dictionary
            ProtectProviderConfigurationData.ProtectConfigurationValue(dictionary);

            stopwatch.Step("Encrypted random in-memory dictionary");

            // Checks that all entries of the in-memory dictioary are encrypted, e.g. do not match DefaultProtectRegexString
            foreach (var entry in dictionary)
            {
                if (entry.Key.Contains("_Encrypted") && entry.Value != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(entry.Value))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {entry.Key} Value {entry.Value}!");
            }

            stopwatch.Step("Checked that all random in-memory dictionary is encrypted");

            // Loads the in-memory dictionary with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddInMemoryCollection(dictionary).Build();

            stopwatch.Step("Loaded and decrypted random in-memory dictionary with ProtectedConfigurationBuilder");

            // Foreach xxx_Plaintext key check that its value is equal to xxx_Encrypted
            var checkedEntries = CheckConfigurationEntriesAreEqual(configuration);

            stopwatch.Step($"Checked that {checkedEntries} entries are equal");
        }

        #endregion





        #region "Command line Tests and helper methods"

        /// <summary>
        /// Generates command line arguments with random (4*NUMENTRIES) in both datatype and value. Command line arguments can only contain string and they aren't hierarchical.
        /// </summary>
        /// <returns>the generated arguments array</returns>
        protected String[] GenerateRandomCommandLine()
        {
            String subPurpose;

            TestOutputHelper.WriteLine($"{DateTime.Now}: Generating a random command line arguments with {NUMENTRIES} keys, autogenerated strings max length {STRINGMAXLENGTH} and autogenerated array max length {ARRAYMAXLENGTH}...");

            var args = new String[4 * NUMENTRIES];

            for (int i = 0; i < NUMENTRIES; i++)
            {
                var entryValue = GenerateRandomValue();
                var entryKey = $"Entry_{i + 1}_{entryValue.DataType}_";

                switch (entryValue.DataType)
                {
                    case DataTypes.Null:
                    case DataTypes.WhitespaceString:
                    case DataTypes.String:
                    case DataTypes.Integer:
                    case DataTypes.Double:
                    case DataTypes.Boolean:
                    case DataTypes.DateTimeOffset:
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        args[4 * i] = $"--{entryKey}Plaintext";
                        args[4 * i + 1] = entryValue.Value?.ToString();
                        args[4 * i + 2] = $"--{entryKey}Encrypted";
                        args[4 * i + 3] = CreateStringProtectValue(subPurpose, entryValue.DataType, entryValue.Value);
                        break;

                    case DataTypes.StringArray:
                    case DataTypes.IntegerArray:
                    case DataTypes.DoubleArray:
                    case DataTypes.BooleanArray:
                    case DataTypes.DateTimeOffsetArray:
                        // command line arguments do not support arrays, we take first value
                        subPurpose = (Random.Next() % 4 == 0) ? TrimRegexCharsFromSubpurpose(GenerateRandomString(SUBPURPOSEMAXLENGTH)) : null;

                        var firstValue = ((Array)entryValue.Value).Cast<object>()?.FirstOrDefault()?.ToString();

                        args[4 * i] = $"--{entryKey}Plaintext";
                        args[4 * i + 1] = firstValue;
                        args[4 * i + 2] = $"--{entryKey}Encrypted";
                        args[4 * i + 3] = CreateStringProtectValue(subPurpose, entryValue.DataType, firstValue);
                        break;
                }
            }


            TestOutputHelper.WriteLine($"{DateTime.Now}: Starting test...");

            return args;
        }


        /// <summary>
        /// Generates random command line arguments with <see cref="NUMENTRIES"/> entries, encrypts them, loads them into IConfigurationRoot using a ProtectedConfigurationBuilder and tests that all decrypted key are equal to plaintext ones.
        /// </summary>
        /// <exception cref="InvalidDataException"></exception>
        [Fact]
        public void RandomCommandLineTest()
        {
            var stopwatch = new ExtendedStopwatch(start: true, testOutputHelper: TestOutputHelper);

            // genererates random command line arguments
            var args = GenerateRandomCommandLine();

            stopwatch.Step("Generated random comand line args");

            // Encrypts the command line arguments
            var encryptedArgs = ProtectProviderConfigurationData.ProtectConfigurationValue(args);

            stopwatch.Step("Encrypted random comand line args");

            // Checks that all command line arguments are encrypted, e.g. do not match DefaultProtectRegexString
            for (int i = 0; i < encryptedArgs.Length / 2; i++)
            {
                if (encryptedArgs[2 * i].Contains("_Encrypted") && encryptedArgs[2 * i + 1] != null)
                    if (ProtectProviderConfigurationData.ProtectRegex.IsMatch(encryptedArgs[2 * i + 1]))
                        throw new InvalidDataException($"Found an invalid un-encrypted environment variable {encryptedArgs[2 * i]} Value {encryptedArgs[2 * i + 1]}!");
            }

            stopwatch.Step("Checked that all random comand line args are encrypted");

            // Loads the command line arguments with ProtectedConfigurationBuilder
            var configuration = new ProtectedConfigurationBuilder(ProtectProviderConfigurationData).AddCommandLine(encryptedArgs).Build();

            stopwatch.Step("Loaded and decrypted random comand line args with ProtectedConfigurationBuilder");

            // For each xxx_Plaintext key check that its value is equal to xxx_Encrypted
            var checkedEntries = CheckConfigurationEntriesAreEqual(configuration);

            stopwatch.Step($"Checked that {checkedEntries} entries are equal");
        }
        #endregion




        /// <summary>
        /// This method is used to remove characters which are used inside the subPurpose group of the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex
        /// </summary>
        /// <remarks>There is no easy way to extract this logic directly fromm the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex, so you have to implement it by yourself in your test according to the regex you use</remarks>
        /// <param name="subpurpose">a random autogenerated subpurpose string</param>
        /// <returns>the random autogenerated subpurpose string with the characters used in the regex removed or replaced</returns>
        protected abstract string TrimRegexCharsFromSubpurpose(string subpurpose);



        /// <summary>
        /// This method is used to remove characters which are used inside the protectData group of the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex
        /// </summary>
        /// <remarks>There is no easy way to extract this logic directly fromm the <see cref="IProtectProviderConfigurationData.ProtectRegex"/> regex, so you have to implement it by yourself in your test according to the regex you use</remarks>
        /// <param name="value">a random autogenerated value string</param>
        /// <returns>the random autogenerated value string with the characters used in the regex removed or replaced</returns>
        protected abstract string TrimRegexCharsFromProtectData(string value);
    }
}
